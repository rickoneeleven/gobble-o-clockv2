Context: Combined Project Brief & Phased Plan for Wear OS Fasting Heart Rate Monitor v2. This file replaces the initial MANIFEST and serves as the primary project reference. This plan is dynamic and expected to change.

--- Project Brief & Specifications ---

Project Objective:
- Create a personal Wear OS application for Galaxy Watch 4+ monitoring real-time heart rate to identify sustained lower periods (potential fasting correlation).
- Runs primarily as a background Foreground Service.
- Samples heart rate approximately once per minute (using a time gate filter).
- Triggers a one-time alert (vibrate/beep) and enters "Gobble Time" state after 5 consecutive processed readings <= user-defined Target Heart Rate.
- Monitoring stops in "Gobble Time" state and only resumes after manual user "Reset".
- Application state (`appState`, `consecutiveCount`) must persist across app/watch restarts.

Target Platform & Tech Stack:
- Target Device: Samsung Galaxy Watch 4 or later (Wear OS 3+).
- Development Environment: Android Studio on macOS.
- Language: Kotlin.
- Core Libraries: Compose for Wear OS (UI), Jetpack DataStore (Preferences for persistence), Health Services API (passive heart rate monitoring), Lifecycle Service (background execution), Coroutines, ViewModel.
- Version Control: Git.

Core Principles:
- Simplicity: Easy to understand and use.
- Clarity: Code and UI should be clear.
- Battery Consciousness: Prioritize minimizing battery drain (using Passive Monitoring, Foreground Service best practices, unregistering listener when idle).
- Mandatory Logging: Implement detailed Logcat logging AND persistent file logging viewable within the app for debugging/tweaking.
- User-Centric: Designed for the primary user's specific needs (initially the developer).
- No Automated Tests: Focus on manual testing for this version.

Key Design Decisions & Logic Details:
- Target Heart Rate: User-defined via app setting. User is responsible for determining the appropriate value; no in-app guidance provided. Default: 70 bpm.
- Sampling Logic: Uses Health Services Passive Listener. To ensure reliability and avoid reacting to transient dips/noise, a time gate (`currentTimeMillis >= lastProcessedTimestamp + ~55000ms`) is applied. Only *one* reading (the latest in a batch) is processed if the gate condition passes. This aims for roughly 1-minute intervals between *processed* readings but depends on Health Services delivery timing.
- Consecutive Reading Definition: "Consecutive" refers to 5 *sequentially processed readings* (i.e., readings that passed the ~1min time gate) that are <= `targetHeartRate`. The actual time elapsed between these processed readings might be more than 1 minute if data delivery is sparse.
- Alert Mechanism: A single, one-time system notification (vibrate/beep) is triggered when entering "Gobble Time". If missed, user must manually check the app. This is acceptable for v2.
- State Persistence (DataStore Keys & Types):
    - `appState`: String ("MONITORING" / "GOBBLE_TIME"), Default: "MONITORING"
    - `consecutiveCount`: Integer (0-5), Default: 0
    - `targetHeartRate`: Integer, Default: 70
    - `lastProcessedTimestamp`: Long (epoch ms), Default: 0
    - `lastDisplayedHr`: Integer (optional, for smoother UI updates), Default: 0
- Background Execution: Mandatory Foreground Service with a persistent notification indicating active monitoring.
- Permissions (`BODY_SENSORS`, `POST_NOTIFICATIONS` [for Android 13+ alerts]):
    - App UI checks on launch/resume. If denied, displays explanation and "Grant Permission" button triggering system request. Blocks function until granted.
    - Service checks on start and stops itself if permission is not granted or revoked.
- In-App Logging: A dedicated UI screen will display timestamped logs read from a persistent file stored in app-internal storage. Will include key events (service state, HR processing, state changes, resets, errors). Basic log management (clear button or rotation) required.

--- Phased Implementation Plan (Reorganized Batches) ---

--- Batch 0: Project Setup & Foundation ---

- [COMPLETED] All Phase 0 tasks.

--- Batch 1: Stabilize Service & Implement Core Logic ---

- [BLOCKED] **Resolve persistent build errors in `HeartRateMonitorService.kt` related to Health Services API.**
    - **Current Blocker:** `Unresolved reference` error for timestamp methods (`getEndOriginTime`, `getTimeInstant`) on `SampleDataPoint`. This prevents compiling the core data processing logic.
    - **Root Cause Analysis:** The necessary timestamp methods appear to be missing from the currently used and attempted `androidx.health:health-services-client` library versions (`1.0.0-rc01`, `1.0.0-rc02`, `1.0.0-beta02`). They were likely introduced in later versions.
    - **Troubleshooting Steps Taken:**
        - Corrected `PassiveListenerCallback` method signatures (using `onNewDataPointsReceived`, removing `onError`).
        - Identified `SampleDataPoint` as the correct `DataPoint` subclass for Heart Rate.
        - Attempted to use `getTimeInstant()` - resulted in `bootInstant` unresolved internal parameter error or `NoSuchMethodError`.
        - Attempted to use `getEndOriginTime()` - resulted in `Unresolved reference` error.
        - Switched from custom `serviceJob` to standard `lifecycleScope` for coroutine launching.
        - Attempted Health Services library updates:
            - `1.1.0`: Failed to download.
            - `1.0.0-rc02`: Downloaded, but `getEndOriginTime` still unresolved.
            - `1.0.0-beta02`: Downloaded, but `getEndOriginTime` still unresolved.
    - **Next Steps:**
        - Re-attempt download of a newer stable version (e.g., `1.1.0` or later) if network/cache issues resolve.
        - OR Inspect the `SampleDataPoint` class definition within the original `1.0.0-rc01` library *very carefully* to find the *actual* timestamp method available in that specific version (might be named differently, e.g., `getTimestamp()`, or require accessing time via a different property).
        - OR Consider if a different approach (e.g., using `SystemClock.elapsedRealtime()` and calculating offset, although less reliable) is feasible as a last resort if no direct timestamp method is available/usable in `1.0.0-rc01`.

- [PENDING] Inject or provide `PreferencesRepository` to `HeartRateMonitorService` (using DI).

- [PENDING] Implement the ~1 minute sampling gate logic within the `PassiveListenerCallback` using `lastProcessedTimestamp`. Log processed/skipped status.

- [PENDING] Implement heart rate processing: update `lastDisplayedHr` (if used), update `lastProcessedTimestamp` in DataStore.

- [PENDING] Implement target comparison logic (`processed HR <= targetHeartRate`).

- [PENDING] Implement consecutive count update logic (increment or reset). Update `consecutiveCount` in DataStore. Log count changes.

- [PENDING] Implement state transition logic (`consecutiveCount >= 5` -> `GOBBLE_TIME`). Update `appState` in DataStore.

- [PENDING] Implement automatic listener unregistration when `appState` becomes `GOBBLE_TIME`. Log state change and unregistration.

- [PENDING] Ensure `HeartRateMonitorService` reads initial state (`appState`, `consecutiveCount`, etc.) from DataStore on start.

- [PENDING] In `HeartRateMonitorService`, implement collection of the `appState` flow from the repository to react to external changes (like Reset).

- [PENDING] Implement Service logic reacting to `appState` changing from `GOBBLE_TIME` -> `MONITORING` (Reset): call `registerPassiveListener()`. Log re-registration.

- [PENDING] Enhance Logcat logging throughout `HeartRateMonitorService` for all implemented logic.

- [PENDING] Commit the functional service core.

--- Batch 2: Develop UI Structure & ViewModel ---

- [PENDING] All Batch 2 tasks.

--- Batch 3: Integrate UI, Service & Permissions ---

- [PENDING] All Batch 3 tasks.

--- Batch 4: Implement Alerting & Persistent Logging ---

- [PENDING] All Batch 4 tasks.