Context: Combined Project Brief & Phased Plan for Wear OS Fasting Heart Rate Monitor v2. This file tracks remaining work.

--- BLOCKER: MainActivity Not Launching on Emulator ---

- **Current Status:** The application compiles successfully and can be installed on a Wear OS emulator. Logcat confirms the application process starts and `MainApplication.onCreate` executes (initializing `PreferencesRepository`). However, `MainActivity.onCreate` does not appear to be called, and the application UI is never displayed; the emulator typically returns to the watch face or app list after installation/launch attempt. No fatal crash logs are observed in Logcat.
- **Problem:** The primary user interface (`MainActivity`) is failing to launch, preventing any UI interaction or visual confirmation of the application state.
- **Suspected Causes:**
    1.  **`AndroidManifest.xml` Configuration Error:** Incorrect declaration of `MainActivity`, missing/incorrect `android:exported` attribute, or malformed `<intent-filter>` for the MAIN/LAUNCHER action.
    2.  **Emulator Issue:** Potential graphics/windowing incompatibility or deeper glitch within the specific emulator instance preventing activity window creation (though less likely to fail silently).
    3.  **System Interference:** Extremely unlikely, but some system process preventing the activity launch.
- **Next Step:** Thoroughly review the `app/src/main/AndroidManifest.xml` file, specifically the `<application>` tag and the `<activity android:name=".presentation.MainActivity">` declaration within it, including its attributes (`android:exported`) and intent filters (`<action android:name="android.intent.action.MAIN" />`, `<category android:name="android.intent.category.LAUNCHER" />`).
- **Impact:** This blocker prevents *any* UI testing or interaction, halting progress on all subsequent UI integration, permission handling, and feature implementation tasks (Batches 2, 3, 4).

--- Project Brief & Specifications ---

Project Objective:
- Create a personal Wear OS application for Galaxy Watch 4+ monitoring real-time heart rate to identify sustained lower periods (potential fasting correlation).
- Runs primarily as a background Foreground Service.
- Samples heart rate approximately once per minute (using a time gate filter based on callback time).
- Triggers a one-time alert (vibrate/beep) and enters "Gobble Time" state after 5 consecutive processed readings <= user-defined Target Heart Rate.
- Monitoring stops in "Gobble Time" state and only resumes after manual user "Reset".
- Application state (`appState`, `consecutiveCount`) must persist across app/watch restarts.

Target Platform & Tech Stack:
- Target Device: Samsung Galaxy Watch 4 or later (Wear OS 3+).
- Development Environment: Android Studio on macOS.
- Language: Kotlin.
- Core Libraries: Compose for Wear OS (UI), Jetpack DataStore (Preferences for persistence), Health Services API (passive heart rate monitoring), Lifecycle Service (background execution), Coroutines, ViewModel.
- Version Control: Git.

Core Principles:
- Simplicity: Easy to understand and use.
- Clarity: Code and UI should be clear.
- Battery Consciousness: Prioritize minimizing battery drain (using Passive Monitoring, Foreground Service best practices, unregistering listener when idle).
- Mandatory Logging: Implement detailed Logcat logging AND persistent file logging viewable within the app for debugging/tweaking.
- User-Centric: Designed for the primary user's specific needs (initially the developer).
- No Automated Tests: Focus on manual testing for this version.

Key Design Decisions & Logic Details:
- Target Heart Rate: User-defined via app setting. User is responsible for determining the appropriate value; no in-app guidance provided. Default: 70 bpm.
- Sampling Logic: Uses Health Services Passive Listener. To ensure reliability and avoid reacting to transient dips/noise, a time gate (`callbackTimeMillis >= lastProcessedTimestamp + ~55000ms`) is applied based on when the data callback is received. Only *one* reading (the latest in a batch) is processed if the gate condition passes. This aims for roughly 1-minute intervals between *processed* readings but depends on Health Services delivery timing. (Note: Using DataPoint timestamp proved problematic, sticking with callback time).
- Consecutive Reading Definition: "Consecutive" refers to 5 *sequentially processed readings* (i.e., readings that passed the ~1min time gate) that are <= `targetHeartRate`. The actual time elapsed between these processed readings might be more than 1 minute.
- Alert Mechanism: A single, one-time system notification (vibrate/beep) is triggered when entering "Gobble Time". If missed, user must manually check the app. This is acceptable for v2.
- State Persistence (DataStore Keys & Types):
    - `appState`: String ("MONITORING" / "GOBBLE_TIME"), Default: "MONITORING"
    - `consecutiveCount`: Integer (0-5), Default: 0
    - `targetHeartRate`: Integer, Default: 70
    - `lastProcessedTimestamp`: Long (epoch ms), Default: 0
    - `lastDisplayedHr`: Integer (optional, for smoother UI updates), Default: 0
- Background Execution: Mandatory Foreground Service with a persistent notification indicating active monitoring.
- Permissions (`BODY_SENSORS`, `POST_NOTIFICATIONS` [for Android 13+ alerts]):
    - App UI checks on launch/resume. If denied, displays explanation and "Grant Permission" button triggering system request. Blocks function until granted.
    - Service checks on start and stops itself if permission is not granted or revoked.
- In-App Logging: A dedicated UI screen will display timestamped logs read from a persistent file stored in app-internal storage. Will include key events (service state, HR processing, state changes, resets, errors). Basic log management (clear button or rotation) required.

--- Phased Implementation Plan (Reorganized Batches) ---

-Context: Combined Project Brief & Phased Plan for Wear OS Fasting Heart Rate Monitor v2. This file tracks remaining work.

--- Batch 1: Stabilize Service & Implement Core Logic ---
 [COMPLETED] - In `HeartRateMonitorService`, implement collection of the `appState` flow from the repository to react to external changes (like Reset from UI).
 [COMPLETED] - Implement Service logic reacting to `appState` changing from `GOBBLE_TIME` -> `MONITORING` (Reset): call `registerPassiveListener()`. Log re-registration.
 [COMPLETED] - Commit the functional service core.

--- Batch 2: Develop UI Structure & ViewModel ---
 [COMPLETED] - Define `MainViewModel` responsible for holding UI state and interacting with `PreferencesRepository`.
 [COMPLETED] - Expose relevant `Flows` via a combined `StateFlow<MainUiState>`.
 [COMPLETED] - Implement UI state (`MainUiState` data class defined).
 [COMPLETED - Code Provided, but BLOCKED by Activity Launch Failure] - Create basic Compose UI layout in `MainActivity`.
 [BLOCKED by Activity Launch Failure] - Connect the UI elements to observe state from the `ViewModel`. (Verify state flows correctly to UI).
 [BLOCKED by Activity Launch Failure] - Implement basic navigation stub for Log screen.
 [BLOCKED by Activity Launch Failure] - Commit initial UI structure and ViewModel.

--- Batch 3: Integrate UI, Service & Permissions ---
 [BLOCKED by Activity Launch Failure] - Implement "Reset" button functionality: Button -> ViewModel -> Repository -> Service Reaction.
 [BLOCKED by Activity Launch Failure] - Implement "Set Target Heart Rate" functionality: Input -> ViewModel -> Repository.
 [BLOCKED by Activity Launch Failure] - Implement UI logic to check for `BODY_SENSORS` permission on Activity launch/resume. Show message/button if denied.
 [BLOCKED by Activity Launch Failure] - Implement the "Grant Permission" button action to trigger the system permission request flow. Handle result.
 [BLOCKED by Activity Launch Failure] - Implement UI logic to check for `POST_NOTIFICATIONS` permission (Android 13+). (Placeholder check/log).
 [BLOCKED by Activity Launch Failure] - Refine UI based on state (e.g., disable "Reset" button).
 [BLOCKED by Activity Launch Failure] - Ensure `MainActivity` correctly starts the `HeartRateMonitorService`. Consider edge cases.
 [BLOCKED by Activity Launch Failure] - Commit integrated UI, service communication, and permission handling.

--- Batch 4: Implement Alerting & Persistent Logging ---
 [BLOCKED by Activity Launch Failure] - Implement the alert mechanism when `appState` transitions to `GOBBLE_TIME` within the service. Check `POST_NOTIFICATIONS`. Create/display notification.
 [BLOCKED by Activity Launch Failure] - Implement persistent file logging: Choose strategy, create logger, add logging calls (Service, Repo, VM, UI), write to internal storage.
 [BLOCKED by Activity Launch Failure] - Implement the Log Viewer UI screen: Read logs, display in list, implement "Clear Logs".
 [BLOCKED by Activity Launch Failure] - Integrate navigation to the Log Viewer screen.
 [BLOCKED by Activity Launch Failure] - Commit alerting and persistent logging features.